import { createSlice } from '@reduxjs/toolkit';import { ITicket } from '../../Components/models/Ticket';import { fetchTickets } from './FetchTickets';import { fetchSearchId } from './FetchSearchId';import { orderBy, maxBy } from 'lodash';type TicketSate = {  tickets: ITicket[];  isLoading: boolean;  isAllTicketsLoaded: boolean;  error: string;  SearchIdKey: string;  filterBtnAll: boolean;  filterBtnNoTransitions: boolean;  filterBtnOneTransitions: boolean;  filterBtnTwoTransitions: boolean;  filterBtnThreeTransitions: boolean;};const initialState: TicketSate = {  tickets: [],  isLoading: false,  isAllTicketsLoaded: false,  SearchIdKey: '',  error: '',  filterBtnAll: true,  filterBtnNoTransitions: true,  filterBtnOneTransitions: true,  filterBtnTwoTransitions: true,  filterBtnThreeTransitions: true,};export const ticketSlice = createSlice({  name: 'ticket',  initialState,  reducers: {    sortButton(state, action) {      if (action.payload === 'быстрый') {        state.tickets = orderBy(          state.tickets,          // (item:ITicket) => maxBy(item.segments, "duration").duration,          (item: ITicket) => item.segments[0].duration + item.segments[1].duration,          'asc'        );      }      if (action.payload === 'дешевый') {        state.tickets = orderBy(state.tickets, ['price'], ['asc']);      }      if (action.payload === 'оптимальный') {        // state.tickets.sort((a,b)=>a.price*(a.segments[0].duration+a.segments[1].duration) - b.price*(b.segments[0].duration+b.segments[1].duration))        state.tickets = orderBy(          state.tickets,          // (item:ITicket) => maxBy(item.segments, "duration").duration,          (item: ITicket) => item.price * (item.segments[0].duration + item.segments[1].duration),          'asc'        );      }    },    selectAll(state) {      if (!state.filterBtnAll) {        state.filterBtnOneTransitions = true;        state.filterBtnTwoTransitions = true;        state.filterBtnThreeTransitions = true;        state.filterBtnNoTransitions = true;      }      state.filterBtnAll = !state.filterBtnAll;    },    selectNoTransitions(state) {      state.filterBtnAll = false;      state.filterBtnNoTransitions = !state.filterBtnNoTransitions;    },    selectOneTransitions(state) {      state.filterBtnAll = false;      state.filterBtnOneTransitions = !state.filterBtnOneTransitions;    },    selectTwoTransitions(state) {      state.filterBtnAll = false;      state.filterBtnTwoTransitions = !state.filterBtnTwoTransitions;    },    selectThreeTransitions(state) {      state.filterBtnAll = false;      state.filterBtnThreeTransitions = !state.filterBtnThreeTransitions;    },  },  extraReducers: {    [fetchTickets.pending.type]: (state) => {      state.isLoading = true;      state.error = '';    },    [fetchTickets.fulfilled.type]: (state, action) => {      const newTickets = action.payload.tickets;      state.tickets.push(...newTickets);      state.isAllTicketsLoaded = action.payload.stop;      if (action.payload.stop) {        state.tickets.sort((a: ITicket, b: ITicket) => a.price - b.price);        state.isLoading = false;      }    },    [fetchTickets.rejected.type]: (state, action) => {      state.isLoading = false;      state.error = action.payload;    },    [fetchSearchId.pending.type]: (state) => {},    [fetchSearchId.fulfilled.type]: (state, action) => {      state.SearchIdKey = action.payload;    },    [fetchSearchId.rejected.type]: (state) => {},  },});export const {  sortButton,  selectAll,  selectNoTransitions,  selectThreeTransitions,  selectTwoTransitions,  selectOneTransitions,} = ticketSlice.actions;export default ticketSlice.reducer;